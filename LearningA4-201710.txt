================================================

00-Setting up ....

https://github.com/mosh-hamedani/organic-shop

https://github.com/ritwickdey/organic-shop


/c/Albert/Angular4/organic-shop-master

{
    "workbench.startupEditor": "newUntitledFile",
    "terminal.integrated.shell.windows": "C:\\Program Files\\Git\\bin\\bash.exe"
}


https://github.com/ritwickdey/organic-shop


====> new project, skipping npm install, then use yarn

node --version
npm install -g @angular/cli
ng --version

ng new progressing --skip-install

--> installing packages for tooling via npm. stuck
I was having the same issue. I resolved by using yarn. Follow below steps

Install yarn through npm using the below command

npm install yarn --global
Create your application using ng new but skip installing packages using the below command. You can install them manually using yarn

Or¡­ you can just tell the CLI to use Yarn instead of NPM!
ng set --global packageManager=yarn


ng new project-name --skip-install
cd project-name
yarn install This will install your dependencies super-fast

npm install --save firebase
npm install --save bootstrap
npm install --save bootstrap@next

====> ng g c ...

https://stackoverflow.com/questions/29786887/how-can-i-make-multiple-projects-share-node-modules-directory


-->
create component or service under subfolders ...

Consider your project is recipe-book.
first navigate to app folder by

cd src
cd app
then if you wants to create component folder in app then simply type
ng g c pagination
this will create ng g c pagination/pagination.component.ts

--> if having component folder ...
ng g c component/pagination
this will create component/pagination/pagination.component.ts


===========================================

06-Directives
====> leading *, telling Anuglar to re-write by using <ng-template>


====> *ngFor, two variables

<ul>
  <li *ngFor="let course of courses; index as i">
    {{ i }} - {{ course.name }}
  </li>
</ul>

====> 28:25
trackBy, this will change how Angular tracks objects, 
for big collection, not reload, track instead to improve performance!



<ul>
  <li *ngFor="let course of courses; index as i; trackBy: trackCourse">
    {{ i }} - {{ course.name }}
  </li>
</ul>


trackCourse(index, course) {
	return course ? course.id : undefined;
}

====> 36:09
[ngClass]
[ngStyle]


====> 36:30 Safe Traversal Operator

Error: TypeError: Cannot read property 'name' of null

Could use ngIf, e.g,

<span *ngIf="task.assignee">{{ task.assignee.name }}</span>

Can use ?

<span">{{ task.assignee?.name }}</span>

====> 39:16 Custom Directives

e.g, format phone number

ng g d input-format

HostListener from @angular/core





===========================================

07 Template-driven Forms ==> contact-form

00:07:20

Template-driven: Directives
Reactive (model-driven): Code

--> ngModel name="firstName" #firstName="ngModel" (change)="log(firstName)"

ngModel directive, need a name attribute!

Angular sees <form>, then adding ngForm ...

<form #f="ngForm" (ngSubmit)="submit(f)">

	<div class="form-group">
		<label for="firstName">First Name<label>
		<input 
			required
			minlength="3"
			maxlength="10"
			pattern="banana"
			ngModel
			name="firstName"
			#firstName="ngModel"
			(change)="log(firstName)"
			id="firstName"
			type="text"
			class="form-control">
	<div>

...

submit(f) {
	console.log(f);
	f.value.firstName ...
}

--> ngModel, ngModelGroup, ngForm(ngSubmit) 33:00

<div ngModelGroup="contact" #contact="ngModelGroup"> --> this is useful if to validate the entire group as a whole

	<div class="form-group">
		<label for="firstName">First Name<label>
		<input 
			required
			minlength="3"
			maxlength="10"
			pattern="banana"
			ngModel
			name="firstName"
			#firstName="ngModel"
			(change)="log(firstName)"
			id="firstName"
			type="text"
			class="form-control">
	<div>
<div>

f.value.contact


div.checkbox>label>input[type='checkbox']

div.form-group>label[for='contactMethod']+select[id='contactMethod'].form-control


==> 

FormControl: one input field, ::> ngModel, angular will internally create an instance of ngControl class and associate with the input field!
FormGroup: multple input fields, ::> ngForm (auto created, uses ngSubmit to expose output attributes), ngModelGroup (cannot submit because it is just a part of a form)


==> option
<option *ngFor="let method of contactMethods" [value]="method.id">{{ method.name }}</option>
vs.
<option *ngFor="let method of contactMethods" [ngValue]="method">{{ method.name }}</option>


[value]="method.id" ::> only binding id
[ngValue]="method" ::> binding complex object


--> select multiple options
<select multiple ngModel name="contactMethod" id="contactMethod">\
vs.
<select ngModel name="contactMethod" id="contactMethod">

==>

debugging on page:

<p>
	{{ f.value | json }}
</p>



===========================================

08 Reactive Forms ==> signup-form, array-form

==> not using ngModel in html, instead, create ngControl instance in the component.ts

==> AbstractControl is a super class of {FormControl, FormGroup}

==> 

Template parse errors:
Can't bind to 'formGroup' since it isn't a known property of 'form'. ("<form [ERROR ->][formGroup]="form">

Need to ReactiveFormsModule in app.module.ts

import { FormsModule, ReactiveFormsModule } from '@angular/forms';

==> AsyncValidatorFn

interface AsyncValidatorFn { 
  (c: AbstractControl): Promise<ValidationErrors|null>|Observable<ValidationErrors|null>
}

==> Promise

var Promise: new PromiseConstructor<T>(

executor: (resolve: (value?: T | PromiseLike<T>) => void, 
			reject: (reason?: any) => void) => void
			

) => Promise<T>

--> resolve is a function, that takes a value and returns void
--> reject, takes a function called reason (optional, takes any as parameter and returns void), and returns void

--> simplified as 
executor: (resolve, reject) => void

::> if success, use resolve function to return the real returning value, e.g, resolve({ result: true })
::> if fail, use reject function to return reason of failure, e.g, reject({ error: 'user error' })


-->
formControlName="username", attribute name "pending", value is true if any validator is in progress.



==> form array: newcourse-form

NewCourseFormComponent



===========================================


09-Consuming HTTP Services

54:00,     return this.http.get(this.url)
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/observable/throw';

==> ErrorHandler
providers: [
	... ...
	{ provide: ErrorHandler, useClass: AppErrorHandler }
]


==> 
122. The Map Operator
4:27
in data.service.ts
getAll() {
	return this.http.get(this.url)
	  .map(response => response.json())
	  .catch(this.handleError);
}

in posts.component.ts
ngOnInit() {
	this.service.getAll()
	  .subscribe(posts => this.posts = posts);
}


==>
123. Optimistic vs Pessimistic Updates
6:25

--> Optimistic: roll back could be so fast and user wouldn't see it, so, normall use Optimistic!
createPost(input: HTMLInputElement) {
	let post = { title: input.value };
	this.posts.splice(0, 0, post);

	input.value = '';

	this.service.create(post)
	  .subscribe(
		newPost => {
		  post['id'] = newPost.id;
		},
		(error: AppError) => {
		  this.posts.splice(0, 1); // roll back here!!!

		  if (error instanceof BadInput) {
			// this.form.setErrors(error.originalError);
		  }
		  else throw error;
		});
}

--> Pessimistic
createPost(input: HTMLInputElement) {
	let post = { title: input.value };
	input.value = '';

	this.service.create(post)
	  .subscribe(
		newPost => {
		  post['id'] = newPost.id;
		  this.posts.splice(0, 0, post);
		},
		(error: AppError) => {
		  if (error instanceof BadInput) {
			// this.form.setErrors(error.originalError);
		  }
		  else throw error;
		});
}


--> simulate error

in data.service.ts
create(resource) {
	return Observable.throw(new AppError()); <---- Here
	return this.http.post(this.url, JSON.stringify(resource))
	  .map(response => response.json())
	  .catch(this.handleError);
}

--> deletePost: follow!!!

==>
124. Observables(mostly used by Angular) vs Promises
6:44

Observables
-- lazy, nothing happens until .subscribe()

Promises
-- eager, as soon as create a promise, it happens
-- then(and catch) method is called after happening

--> because Observables have many other powerful operators, called reactive programming, e.g, retry(3),
they are only called after .subscribe()



===========================================

10-Routing and Navigation

==> Steps

Configure the routes
Add a router outlet
Add links


==> 10:55



===========================================

11-Authentication and Authorization

==> package.json

"angular2-jwt": "^0.2.3",

npm install angular2-jwt --save

==> fake-backend.ts
abc@abc.com
123

jwt.io !!!! --> security for the signature is ONLY on server, NOT on client!

==> order.service.ts
import 'rxjs/add/operator/map';


app.module.ts

==> login

login.component.ts

auth.service.ts


==> logout

home.component.html
auth.service.ts


==> isExpired,
when generating a token, it should be with an expiration date.


==> admin: can have a roles array in token ...

==> canActivate: 40:00

...\11-auth-demo-starter\auth-demo-starter\src\app>ng g s services/auth-guard

app.module.ts

==> redirecting! 45:30

pass query parameter, returnUrl

48:52, using this.route.snapshot ...!!!

don't have to subscribe to query parameter map Observable??

==> admin link only to admin user ... 50:20

...\11-auth-demo-starter\auth-demo-starter\src\app>ng g s services/admin-auth-guard

admin-auth-guard.service.ts

==> Accessing Protected API Resource, 56:03

order.service.ts, need to include Authorization header in request

01:01:10, introducing angular2-jwt AuthHttp

--> http: AuthHttp, all methods, internally, implemented token checking ..., Bearer token
--> Note: the configuration in app.module.ts for AuthHttp!



!!!!!!!!!!!!!!!!!!!!!!>

Error:
EmptyError: no elements in sequence

Solution: add pathMatch: 'full'
{ path: '', component: HomeComponent, pathMatch: 'full' },

https://stackoverflow.com/questions/39734085/angular-2-0-1-router-emptyerror-no-elements-in-sequence

Add pathMatch: 'full'

{ path: '', component: HomeComponent, pathMatch: 'full' },
otherwise both routes

{ path: '', component: HomeComponent },
{ path: 'schedule', component: ScheduleComponent },
match on route /schedule because '' matches, but doesn't consume anything from the route and then also 'schedule' matches.


===========================================

12-Deployment:

ng build -prod

==>
Github Pages:
https://pages.github.com/

--> static contents, html, css, javascript ...

npm i -g angular-cli-ghpages --> github pages

ng build --prod --base-href="https://oopsmails.github.io/nameofrepo/" --> trailing slash!

angular-cli-ghpages --> or short form: ngh

ngh --no-silent --> for displaying real error message: e.g, permission denied

Go to: https://oopsmails.github.io/nameofrepo/

Shortcut: package.json, script, 

"deploy:gh": "ng build --prod --base-href='.../' && ngh" --> or sudo ngh


==> Firebase: backend, cloud, messaging, nosql database ...

https://console.firebase.google.com/

npm i -g firebase-tools

firebase login

firebase init

:: select hosting 
:: open firebase.json, define the folder to deploy

{
	"hosting": {
		"public": "dist",
		"rewrites": [
			{
				"source": "**",
				"destination": "/index.html"
			}
		]
	}
}

ng build --prod
firebase deploy

:: url: https://app-name.firebaseapp.com/

Project Console: https://console.firebase.google.com/project/progressing-oopsmails/overview
Hosting URL: https://progressing-oopsmails.firebaseapp.com

==> Heroku: backend!!!! Node.js!!!

heroku, register

heroku cli, install

heroku --version
heroku login


PS C:\Liu\Angular4\a4-mosh-course\progressing> heroku --version
heroku-cli/6.14.36-15f8a25 (windows-x64) node-v8.7.0
PS C:\Liu\Angular4\a4-mosh-course\progressing> heroku login
Enter your Heroku credentials:
Email: oopsmails@gmail.com
Password: ************
Logged in as oopsmails@gmail.com
PS C:\Liu\Angular4\a4-mosh-course\progressing>


heroku create
heroku open

package.json
:: move angular-cli to dependencies from dev-dependencies

:: Node.js, server.js

npm i express --save

package.json: node server.js


===========================================

13

===========================================

14

===========================================


15-Angular Material2

====> Steps to introduce in

1. npm i --save @angular/cdk @angular/material @angular/animations hammerjs

2. styles.css
@import "~bootstrap/dist/css/bootstrap.css";
@import "~@angular/material/prebuilt-themes/indigo-pink.css";
body {padding-top: 80px}

3. app.module.ts
import { MdCheckboxModule } from '@angular/material';

4. app.component.html
<md-checkbox>Subscribe to</md-checkbox>


====> Custom Injection Token: 

see 15 Angular Material 2, 01:26:00
--> solving the problem of passing data into dialog box, using custom injection token behind MdDialog

For dependency injection in contructor, if a type of number or string or any, Angular cannot know that
at compilation time, so, need to specially configured in app.module.ts, providers.

providers: [
    CoursesService,
    UsertokenService,
	{ provide: CoursesService, useClass: CoursesService },
	{ provide: DIALOG_DATA, useValue: {} }
],



Example:


1. in EditCourseComponent, export const DIALOG_DATA = new InjectionToken('DIALOG_DATA');

2. in app.module.ts, { provide: DIALOG_DATA, useValue: {} }
--> whenever find DIALOG_DATA when compiling, pass the empty object during dependency injection.


3. in EditCourseComponent, constructor(@Inject(DIALOG_DATA) data: any) {
... ...
}

====> real MdDialog, no need to define custom injection token, because Angular already defines
MD_DIALOG_DATA

in EditCourseComponent, 

constructor(@Inject(MD_DIALOG_DATA) data: any) {
	
}

in AppComponent

constructor(private dialog: MdDialog) {
}

openDialog() {
	this.dialog.open(EditCourseComponent, {
		data: { courseId: 1 }
	})
	.afterClosed()
	.subscribe(result => consule.log(result));
}


====> Cohesion:

Things are related should be together, things are not related should not be together.


see 15 Angular Material 2, 01:36:00

ng g m md-components


@NgModule({
	exports: [
		....
	]
})



====> SASS: 01:39:00

CSS Preprocessor: convert future CSS to standard CSS, like typescript to javascript, e.g, LESS, SASS, Stylus ...

Anuglar supports SASS: Syntactically Awesome Style Sheet

1. new theme.scss
2. in .angular-cli.json,

"styles": [
	"stules.css",
	"theme.scss"
]

3. 01:47:30, SASS syntax

varables
@import
@mixin and @include ccc(param)


4. need re-compile see taking in effect


====> custom theme
~01:53:00


====> typography

fonts.google.com


====> More CSS, CSS3:

====> CSS, 

@media screen and (min-width: 480px) {
    body {
        background-color: lightgreen;
    }
}

==> __ and --
https://css-tricks.com/bem-101/

/* Block component */
.btn {}

/* Element that depends upon the block */ 
.btn__price {}

/* Modifier that changes the style of the block */
.btn--orange {} 
.btn--big {}

==> CSS Pseudo-elements
https://www.w3schools.com/css/css_pseudo_elements.asp

Notice the double colon notation - ::first-line versus :first-line

The double colon replaced the single-colon notation for pseudo-elements in CSS3. This was an attempt from W3C to distinguish between pseudo-classes and pseudo-elements.

The single-colon syntax was used for both pseudo-classes and pseudo-elements in CSS2 and CSS1.

For backward compatibility, the single-colon syntax is acceptable for CSS2 and CSS1 pseudo-elements.

--> 
selector::pseudo-element {
    property:value;
}

--> e.g, :before, :after, 
p::first-line {
    color: #ff0000;
    font-variant: small-caps;
}


/* unvisited link */
a:link {
    color: #FF0000;
}

/* visited link */
a:visited {
    color: #00FF00;
}

The ::before pseudo-element can be used to insert some content before the content of an element.

The following example inserts an image before the content of each <h1> element:

Example
h1::before {
    content: url(smiley.gif);
}

::selection {
    color: red;
    background: yellow;
}

===========================================

16-Redux

====> angular 4 redux

ngrx/store: github.com/ngrx/store --> re-implementing Redux pattern with Angular rx way
ng2-redux: github.com/angular-redux/ng2-redux --> build on top of real Redux, most compatible with Redux

--> with pure Redux
http://blog.ng-book.com/introduction-to-redux-with-typescript-and-angular-2/


--> @ngrx/store + @ngrx/core
https://www.pluralsight.com/guides/front-end-javascript/ui-state-management-with-redux-in-angular-4
https://github.com/Kaizeras/ngx-redux-ui-management-recipes

::>
https://blog.nrwl.io/using-ngrx-4-to-manage-state-in-angular-applications-64e7a1f84b7b

init commit:
https://github.com/vsavkin/state_management_ngrx4/commit/41db9537517f3e8beec4eda09a6c11720423420c

https://github.com/vsavkin/state_management_ngrx4



::>
https://blog.realworldfullstack.io/real-world-angular-part-4-state-of-my-spa-10bf90c5a15



==> To update library, 

PS C:\Github\angular-05\16-ReduxToDoList> nvm install 7.9.0
PS C:\Github\angular-05\16-ReduxToDoList> nvm use 7.9.0
Now using node v7.9.0 (64-bit)

==> install ng2-redux

npm install redux ng2-redux --save

npm install @angular-redux/store --save


Uninstalled angular cli npm uninstall @angular/cli -g
Installed rxJS npm install rxjs
Cleared cache npm cache clean
Installed angular cli npm install @angular/cli -g


==> 

create app/store.ts
app.module: add contructor

npm install tassign --save

npm install immutable --save : there is a trade of for using immutable or tassign!!!

==> Reducer: A function that specifies how the state changes in response to an action.
A reducer does NOT modify the state. It returns the new state.

==> 31:45
resovle Observable destory problem with @select(which is returning an Observable!) and asyc pipe {{ counter | asyc }}

--> @select usage:
@select('counter') count;
@select(['messaging', 'newMessages']) newMessages; // path
@select((s: IAppState) => s.messaging.newMessages) newMessages; // arrow function

--> returning new state

1. javascript: not type safe
Object.assign({}, state, { counter: state.counter + 1 });
-> Object.assign({}, state, { counter: state.counter + 1, isOnline: true }); // no compilation error

2. tassign: type safe, preferred with unit tests!
npm install tassign --save
tassign(state, { counter: state.counter + 1 })
-> but this will NOT stop mutating state before or after ...

state.counter++; // wrong and cannot be caught when compiling
return  tassign(state, { counter: state.counter + 1 })
-> unit tests, one is to ensure the right returning value, the other is to make the SOURCE state is NOT modified.

3. use immutable object: 41:40 ... NOT preferred!!! 
More, may not with good support with 
@select('counter') count; // state.get('counter') <-- may not be supported
Have to use,
@select(s => s.get('counter')) newMessages; // arrow function

npm install immutable --save

import { fromJS, Map } from 'immutable'
export class AppModule {
  constructor(ngRedux: NgRedux<Map<string, any>>) { <-- lost type checking here!
    ngRedux.configureStore(rootReducer, INITIAL_STATE);
  }
}
fromJS(INITIAL_STATE)

and in store.ts
export function rootReducer(state: Map<string, any>, action): Map<string, any>

return state.set('counter', state.get('counter') + 1); <-- get and set to change immutalbes

==> enable Redux dev tools
-- install chrome Redux dev tools
-- app.module.ts:
import { NgModule, isDevMode } from '@angular/core';

export class AppModule {
  constructor(ngRedux: NgRedux<IAppState>, devTools: DevToolsExtension) {
    const enhancers = isDevMode() ? [devTools.enhancer()] : [];
    ngRedux.configureStore(rootReducer, INITIAL_STATE, [], enhancers);
  }
}
-- open chrome Redux dev tooling

==> calling service to talk to backend server.
57:05 ...
see todo-list2.component.ts

==> 16f-ReduxComplexDomains is NOT working ... till: 20171124

because there is a bug in combineReducers.

see https://github.com/Microsoft/TypeScript/issues/16795



===========================================

17-UnitTesting

==> Angular uses Karma test runner (*.spec.ts) and Jasmine testing framework

==> Arrange, Act, Assert

==> ng test --code--coverage


===========================================

18-IntegrationTesting

==> ng g c xxx: will generate spec testing files

==. beforeEach(async(() => {

async is for accessing file system ... 07:00
.compileComponents() ...
--> not necessay with webpack

====> todos.component.spec.ts
::> example for dependency injection

====> user-details.component.spec.ts
::> example for router

before instantiate Observable, 
params: Observable<any> = Observable.empty();

::> error
Chrome 62.0.3202 (Windows 7 0.0.0) ERROR
Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'ng:///DynamicTestModule/UserDetailsComponent_Host.ngfactory.js'.
at http://localhost:9876/_karma_webpack_/polyfills.bundle.js:2281


::> to push a value into an Observable!!! 45:35

const route: ActivatedRouteStub = TestBed.get(ActivatedRoute);

====> app.routes.spec.ts
::> router configuration

{ path: 'users', component: UsersComponent },


====> router-outlet
::> router-outlet

'router-outlet' is not a known element:


====> nav folder

::> NO_ERRORS_SCHEMA, 58:40
this tells Angular to ignore any elements or attributes it doesn't recognize.
if having a very complex template which has a lot of components or directives, you may find this is easier ...
but cannot catch "<app-nav2>" ...

====> highlight.directive.spec.ts
to test attribute directive, should create hosting components in test class and test various scenarios.
add DirectiveHostComponent in test class.

::> Note this, this.el.nativeElement.style.backgroundColor = this.bgColor || this.defaultColor;


====> todos.component.spec.ts and todos.component.ts
component with async operations

==> what if ngOnInit() of todos.component.ts returning Promise

this.service.getTodosPromise().then(t => this.todos = t);
-->
spyOn(service, 'getTodosPromise').and.returnValue(Promise.resolve([ [1, 2, 3] ]));
--> 
"expect WAS CALLED" before "THEN WAS CALLED"
--> because async call ... is delayed, javascript engine puts the call back function in the queue and excutes it after
--> why this is NOT happening with Observable? because the call back function of '.subcribe()' is executed immediately!
--> this is a difference between Promise and Observable
--> to fix the test, 

-> we need to wrap the test function in the async function of Angular and fixtrue.whenStable();
-> or use fakeAsync

--> Also note, Observable is using array of array, Promise is using just array???

spyOn(service, 'getTodos').and.returnValue(Observable.from([ [1, 2, 3] ]));
spyOn(service, 'getTodosPromise').and.returnValue(Promise.resolve([ 1, 2, 3] ));



===========================================

19-Project Getting started

ng new oshop
npm install --save firebase@4.2.0 angularfire2@4.0.0-rc.1

app.module.ts ::> install firebase

npm install --save bootstrap
(bootstrap@3.3.7)

npm install --save bootstrap@next
(bootstrap@4.0.0-beta.2) ::> if 4.0.0 is officially then don't need @next

style.css ::> @import "~bootstrap/dist/css/bootstrap.css";

nav-bar, from https://getbootstrap.com/docs/4.0/examples/starter-template/

ng g c bs-navbar

------

ng g c home
ng g c products
ng g c shopping-cart
ng g c check-out
ng g c order-success
ng g c my-orders
ng g c admin/admin-products
ng g c admin/admin-orders
ng g c login

------

https://ng-bootstrap.github.io
https://ng-bootstrap.github.io/#/components/dropdown/examples

npm i --save @ng-bootstrap/ng-bootstrap
@ng-bootstrap/ng-bootstrap@1.0.0-beta.7

------
firebase --version
npm i g firebase-tools ::> this may need to be installed outside VS Code.


firebase login

firebase init

::> hosting
::> Select a default Firebase project for this directory: oshop (oshop-42246)

--> firebase.json

--> ng build --prod

firebase deploy

Project Console: https://console.firebase.google.com/project/oshop-42246/overview
Hosting URL: https://oshop-42246.firebaseapp.com


===========================================

20-Project Authentication and Authorization

ng g s auth
ng g s auth-guard
ng g s user
ng g s admin-auth-guard

Go to firebase, console of oshop app, Authentication ..., enable Google Authentication

login user can be verified in firebase dashboard of the application.

--> working with firebase, should ALWAYS unsubscribe!
1. implements OnDestory interface
2. use async pipe

--> extract auth to service

--> 38:00
returnUrl cannot be passed to Google auth and then make it sent back to our application, then
we have to store it into local storage.

--> 42:45
Observable.subcribe() is called in AppComponent, theoretically need .unsubscribe, but in practice no need,
since this AppComponent is root component, we only have a single instance in the DOM, then we have a 
single subscription of this Observable and it will be there throughout the life time of the application.
If the user navigates away from this application, then this subscription will not work anymore.
If willing to unsubscribe, then feel free to implement OnDestory.

For other components, which are added or removed dynamically in the DOM, if using Observable, 
need to unsubscribe, otherwise, memory leak.

--> firebase only has authentication, but no authorization.

--> 49:50:
different ways of defining roles,

1. users table, add one boolean column called isAdmin
simplest, but not scale well with multiple roles, e.g, store manager ...

2. roles table,
scale better

3. permissions on operations,

--> 01:10:05, at this point, browser will crash!!!
reason: async pipe, everytime there is a new Observable value, Angular thinks there is a change, and will
run change detaction, because Angular thinks the state of the application is changed. The thing is we used
switchMap in auth.service, when Angular runs to html (auth.appUser$ | async as user), the switchMap gives 
a new value and then .map to another value, then Angular tries to render html till (auth.appUser$ | async as user) and gets a new 
value ....

get rid of async pipe! 01:12:00

declare AppUser in BsNavbarComponent and subscribe in constructor, then use this appUser in Html.
Also, no need to unsubscribe appUser in BsNavbarComponent, because there is only one single instance 
of BsNavbarComponent in our DOM and it will stay there for the life time of our application.

--> !!!! when changed isAdmin from true to false, those links are removed immediately!! 
because we have that .subcribe in memory!
!!! don't have to refresh or logout/login !!!


===========================================

21-Project Product Management Module

==>
ng g c admin/product-form
ng g s category
ng g s product

div.form-group>label+input.form-control

==> bootstrap addon, for adding $ sign before price

bootstrap ::> Doc ::> Component ::> 

==> adding ngModel

--> <input ngModel name="title"
--> app.model.ts, adding FormsModule

--> 25:59, validation ...


===========================================

22

===========================================

23

===========================================

24

===========================================

25

===========================================

====> Promise and Observable:

Observable: need to destroy! Otherwise, memory leak.
asyc pipe takes care ...


===========================================

====> Extra section: create your own Modules

1. C:\Albert\Angular4\a4-course>ng g module modules/first-module
  create src/app/modules/first-module/first-module.module.ts (195 bytes)

2. C:\Albert\Angular4\a4-course>ng g c modules/first-module
  create src/app/modules/first-module/first-module.component.html (31 bytes)
  create src/app/modules/first-module/first-module.component.spec.ts (664 bytes)
  create src/app/modules/first-module/first-module.component.ts (292 bytes)
  create src/app/modules/first-module/first-module.component.css (0 bytes)
  update src/app/modules/first-module/first-module.module.ts (280 bytes)

3. in FirstModuleModule

exports: [
	FirstModuleComponent // <-- this!
]

4. in client AppModule

imports: [
	BrowserModule,
	FirstModuleModule // import it in imports, NOT declarations
],


5. in client, use it,

<app-first-module>Testing first-module</app-first-module>


6. npm install ng-packagr --save-dev

==> !!!!!!!!!!! continue to follow at home, https://medium.com/@ngl817/building-an-angular-4-component-library-with-the-angular-cli-and-ng-packagr-53b2ade0701e


--> As per the ng-packagr docs, we¡¯ll need to add two files to our project, ng-package.json and public_api.ts

7.

Add the following to ng-package.json:
{
  "$schema": "./node_modules/ng-packagr/ng-package.schema.json",
  "lib": {
    "entryFile": "public_api.ts"
  }
}

8. export your first-module.module.ts from public_api.ts:

export * from './src/app/modules/first-module/first-module.module.ts'

9. package.json

::> add script
"packagr": "ng-packagr -p ng-package.json"

::>
"private": false,

10. create package,

npm run packagr

....
Built Angular library from C:\Liu\Angular4\a4-mosh-course\progressing, written to C:\Liu\Angular4\a4-mosh-course\pro
gressing\dist


11.a. Pack it for local development


PS C:\Liu\Angular4\a4-mosh-course\progressing\dist> npm pack
progressing-0.0.0.tgz
PS C:\Liu\Angular4\a4-mosh-course\progressing\dist>

The 0.0.0 part comes from the top of your package.json. You¡¯ll want to keep bumping that up as you start to truly deploy your component library for consumption.
From other Angular applications on your system that require your component library, you can npm install ../some-relative-path/dist/my-component-library-0.0.0.tgz to install your component library into your application.


11.b. Publish it on npm

Once you login to your npm account with npm login you can publish your component library with npm publish dist. Just be sure that you have a unique package name (hint: my-component-library may be taken). Once published, you¡¯ll be able to install your component library from npm with npm install my-component-library.


12. Consuming your component library


Once installed, you can import your header component into any application¡¯s app.module.ts, by including it in its @NgModule imports array¡­
import { HeaderModule } from 'my-package-name';
@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HeaderModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
And using its selector in a template as you would a component that is part of your application.


===========================================


angular5+ngrx-store4: @Effect

====> ngrx @Effects() explained
https://stackoverflow.com/questions/39552067/what-is-the-purpose-of-ngrx-effects-library

====> Angular 5 and ngrx/store v4 example
https://blog.angular.io/announcing-ngrx-4-87df0eaa2806

====> Using NgRx 4 to Manage State in Angular Applications
https://blog.nrwl.io/using-ngrx-4-to-manage-state-in-angular-applications-64e7a1f84b7b
https://github.com/vsavkin/state_management_ngrx4

====> NgRx 4: Advanced Patterns and Techniques
https://blog.nrwl.io/ngrx-patterns-and-techniques-f46126e2b1e5



----> Effects classes have three roles:

---- They decide on how to process actions.
---- They transform actions into other actions.
---- They perform side effects.

---- Action Deciders: They decide on how to process actions.

-- Filtering Decider, ofType, e.g:
@Effect() addTodo = this.actions.ofType('ADD_TODO').
    concatMap(todo => this.http.post(…).
    map(() => ({type: 'TODO_ADDED', payload: todo})));


-- Content-Based Decider, based on payload content, e.g:
@Effect() addTodo = this.actions.typeOf('ADD_TODO').map(add => {
if (add.payload.addLast) {
  return ({type: 'APPEND_TODO', payload: add.payload});
} else {
  return ({type: 'INSERT_TODO', payload: add.payload});
}
});

-- Context-Based Decider, e.g;
@Effect() addTodo = this.actions.typeOf('ADD_TODO').map(addTodo => {
if (this.env.confirmationIsOn) {
  return ({type: 'ADD_TODO_WITH_CONFIRMATION', payload: addTodo.payload});
} else {
  return ({type: 'ADD_TODO_WITHOUT_CONFIRMATION', payload: addTodo.payload});
}
});

-- Splitter, e.g:
@Effect() addTodo = this.actions.typeOf('REQUEST_ADD_TODO').flatMap(add => [
	{type: 'ADD_TODO', payload: add.payload},
	{type: 'LOG_OPERATION', payload: {loggedAction: 'ADD_TODO', payload: add.payload}}
]);

-- Aggregator, e.g:
@Effect() aggregator = this.actions.typeOf(‘ADD_TODO’).flatMap(a =>
zip(
  // note how we use a correlation id to select the right action
  this.actions.filter(t => t.type == 'TODO_ADDED' && t.payload.id === a.payload.id).first(),
  this.actions.filter(t => t.type == ‘LOGGED' && t.payload.id === a.payload.id).first()
)
).map(pair => ({
type: 'ADD_TODO_COMPLETED',
payload: {id: pair[0].payload.id, log: pair[1].payload}
}));

Aggregator are not as common as say splitters, so RxJs does not come with an operator implementing it. That's why we had to add some boilerplate to do it ourselves. But could always introduce a custom RxJS operator to help with that.


---- Action Transformers: They transform actions into other actions.

-- Content Enricher, e.g:
@Effect() addTodo = this.actions.ofType('ADD_TODO').
map(add => ({
   action: 'ADD_TODO_BY_USER',
   payload: {...add.payload, user: this.currentUser}
}));

This example is very basic: we merely add the already available current user to the payload. In a more interesting example we would fetch data from the backend and add it to the payload.

-- Normalizer & Canonical Actions, e.g:
@Effect() insertTodo = this.actions.ofType('INSERT_TODO').
map(insert => ({
  action: 'ADD_TODO',
  payload: {...insert.payload, append: false}
}));

@Effect() appendTodo = this.actions.ofType('APPEND_TODO').
map(insert => ({
  action: 'ADD_TODO',
  payload: {...insert.payload, append: true}
}));




---- Building Blocks:


class TodosEffects {
  constructor(private actions: Actions, private currentUser: User, private http: Http) {}

  @Effect() addTodo =
     this.actions.ofType('ADD_TODO'). // filtering decider
     map(t => ({type: t.type, payload: {...payload, user: this.currentUser}})). // content enricher
     map(t => t.append ? // content-based decider
        ({type: 'APPEND_TODO', payload: t.payload}) :
        ({type: 'INSERT_TODO', payload: t.payload})).
     flatMap(t => [t, {type: 'LOG_OPERATION', payload: t}]); // splitter
  @Effect() appendTodo =
    this.actions.ofType('APPEND_TODO').
    mergeMap(t => this.http.post(...));

  @Effect() insertTodo =
    this.actions.ofType('INSERT_TODO').
    mergeMap(t => this.http.post(...));
}



===========================================

Typescript: 

====> Dictionary, ES6 Map

https://stackoverflow.com/questions/13631557/typescript-objects-as-dictionary-types-as-in-c-sharp

var map: { [email: string]: Customer; } = { };
map['foo@gmail.com'] = new Customer(); // OK
map[14] = new Customer(); // Not OK, 14 is not a string
map['bar@hotmail.com'] = 'x'; // Not OK, 'x' is not a customer

interface StringToCustomerMap {
    [email: string]: Customer;
}

var map: StringToCustomerMap = { };
// Equivalent to first line of above




===========================================

VS Code:

====> vs code clear terminal: ctrl + k
====> multiple words selection: ctrl + d, or Alt + click

====> Search "files to exclude"
*.js, *.js.map, *.json, *.lock, *.md

====> Error: Extension host terminated unexpectedly. Please reload the window to recover.
Reason: when copy from other resource directly into workspace with git supported, if copied over
.git of outside, then this error shows up.
Solution: delete the .git file NOT belong to current git.

====> Complete removing

%USER%\.vscode\extensions
C:\Users\liu\AppData\Roaming\Code

====> disable auto update

File > Preferences > Settings (ctrl + comma) and add the update.channel setting with the value "none".

====> auto save
"files.autoSave": "afterDelay",

Turn on Auto Save is with the File > Auto Save

====> 


===========================================

https://scotch.io/tutorials/3-ways-to-pass-async-data-to-angular-2-child-components

====> Problem: consuming-http.component, using http to get all posts in ngOnInit(). But
the pagination component is initialized before its parent's ngOnInit(), then, the pagination
html is not properly working. 

--> Solution 1: in consuming-http.component.html, add

<div *ngIf="itemCount > 0">
	<app-pagination2 ...
</div>


--> Solution 2: ngOnChanges is a lifecycle hook that run whenever it detects changes to 
input properties. That means it's guaranteed that everytime data input value changed, 
our grouping logic will be triggered if we put our code here.

ngOnChanges(changes: SimpleChanges): void {
	if (changes['pageNumber']) {
		console.log('Pagination2Component, ngOnChange: itemcount', this.itemCount);
		this.numOfPages = this.calcNumOfPages();
		this.setCurrentPage(this.currentPage);
	}
}

::> In our pagination case, Solution 2 will NOT work independently ..., need to work with Solution 1. 
If not going to do things, e.g, sorting in pagination component, then MAY NOT need Solution 2, just
use Solution 1.

--> Solution 3: NOT tried



===========================================

====> progressing: bs-navbar

ng g c component/bs-navbar

npm i --save @ng-bootstrap/ng-bootstrap

app.module.ts, app.component.html


===========================================




===========================================
ERROR collection:


==> ERROR: ng-bootstrap found version 4, expected 3
package.json: upgrade from "^4.2.4" to "^5.0.0"

==> ERROR: ERROR in Error: The Angular Compiler requires TypeScript >= 2.4.
package.json: "typescript": "~2.4.2"

====> Error: Uncaught (in promise): EmptyError: no elements in sequence
Also solved by adding 

pathMatch: 'full'

====> Error: angular 4 homepage show twice - Google Search

let's me explain some concept: first your AppComponent is root component, when you 
using <router-outlet></router-outlet>, it's create a placeholder for any route, 
then content of Component defined by route (LoginComponent for example) will be 
put after this point. so in your AppComponent you have <h1>Hello {{name}}</h1> 
then when navigate to any route, the Component still alive, so you got Hello Angular. 
To remove this, just remove <h1>Hello {{name}}</h1> so your AppComp like this 
template: '<router-outlet></router-outlet>'




